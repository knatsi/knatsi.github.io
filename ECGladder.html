<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECG Ladder Diagram v2</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            margin-bottom: 20px;
            color: #333;
        }
        
        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 5px;
        }
        
        button {
            padding: 10px 15px;
            border: none;
            background: #4CAF50;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button.active {
            background: #2196F3;
        }
        
        button.clear {
            background: #f44336;
        }
        
        button.clear:hover {
            background: #da190b;
        }
        
        .canvas-container {
            border: 2px solid #ddd;
            background: white;
            overflow: auto;
            position: relative;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
        }
        
        .info {
            margin-top: 15px;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 4px;
            font-size: 14px;
            color: #1976d2;
        }
        
        .color-picker {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="color"] {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        input[type="number"] {
            width: 70px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        label {
            font-size: 14px;
            color: #555;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ECG Ladder Diagram Drawing Tool</h1>
        
        <div class="toolbar">
            <button id="drawLine" class="active">Draw Line</button>
            <button id="adjust">Adjust</button>
            <button id="drawDot">Draw Symbol</button>
            <button id="eraser">Eraser</button>
            
            <div class="color-picker">
                <label>Symbol:</label>
                <select id="symbolType">
                    <option value="dot">● Dot</option>
                    <option value="arrow">→ Arrow</option>
                    <option value="singleLine">⊥ Single Line</option>
                    <option value="doubleLine">⊥⊥ Double Line</option>
                </select>
            </div>
            
            <div class="color-picker">
                <label>Color:</label>
                <input type="color" id="colorPicker" value="#000000">
            </div>
            
            <div class="color-picker">
                <label>Line Width:</label>
                <input type="number" id="lineWidth" min="1" max="10" value="2">
            </div>
            
            <button id="undo">Undo</button>
            <button id="clear" class="clear">Clear All</button>
        </div>
        
        <div class="toolbar">
            <div class="color-picker">
                <label>Load ECG XML:</label>
                <input type="file" id="ecgFile" accept=".xml">
            </div>
            
            <div class="color-picker" id="leadSelector" style="display: none;">
                <label>Select Lead:</label>
                <select id="leadDropdown"></select>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="canvas" width="1200" height="450"></canvas>
        </div>
        
        <div class="info">
            <strong>Instructions:</strong> Click and drag to draw. The ladder shows three chambers: Atria (A), AV Node (AV), and Ventricles (V). Use different tools to create your ECG ladder diagram showing electrical conduction paths.
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let isDrawing = false;
        let currentTool = 'line';
        let currentColor = '#000000';
        let currentLineWidth = 2;
        let currentSymbol = 'dot';
        let startX, startY;
        let tempStartX, tempStartY;
        let history = [];
        let tempCanvas = document.createElement('canvas');
        let tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        
        // Store all drawn lines and symbols
        let lines = [];
        let symbols = [];
        let hoveredEndpoint = null;
        let draggingEndpoint = null;
        let hoveredSymbol = null;
        let draggingSymbol = null;
        
        // ECG data
        let ecgData = null;
        let ecgLeads = [];
        let currentLead = null;
        let ecgHeight = 150;
        
        // Helper line
        let mouseX = -1;
        let showHelperLine = false;
        
        const atriaStart = ecgHeight;
        const ladderHeight = canvas.height - ecgHeight;
        const atriaHeight = ladderHeight * 0.25;
        const avHeight = ladderHeight * 0.5;
        const ventricleLine = atriaStart + atriaHeight + avHeight;
        const ventricleHeight = ladderHeight * 0.25;
        
        const halfStepA = atriaHeight / 4;
        const halfStepAV = avHeight / 4;
        const halfStepV = ventricleHeight / 4;
        
        const snapLines = [
            atriaStart,                                          // Top of ladder (bottom of ECG)
            atriaStart + halfStepA,                             // Half step below top (in A)
            atriaStart + atriaHeight / 2,                       // A center
            atriaStart + atriaHeight - halfStepA,               // Half between A and AV
            atriaStart + atriaHeight,                           // A/AV border line
            atriaStart + atriaHeight + halfStepAV,              // Half between A and AV (in AV)
            atriaStart + atriaHeight + avHeight / 2,            // AV center
            ventricleLine - halfStepAV,                         // Half between AV and V (in AV)
            ventricleLine,                                      // AV/V border line
            ventricleLine + halfStepV,                          // Half between AV and V (in V)
            ventricleLine + ventricleHeight / 2,                // V center
            canvas.height - halfStepV,                          // Half step above bottom (in V)
            canvas.height                                       // Bottom edge
        ];
        
        function snapToLine(y) {
            let closest = snapLines[0];
            let minDist = Math.abs(y - snapLines[0]);
            
            for (let line of snapLines) {
                let dist = Math.abs(y - line);
                if (dist < minDist) {
                    minDist = dist;
                    closest = line;
                }
            }
            
            return closest;
        }
        
        function isNearPoint(x, y, px, py, threshold = 8) {
            return Math.abs(x - px) < threshold && Math.abs(y - py) < threshold;
        }
        
        function findEndpointAtPosition(x, y) {
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (isNearPoint(x, y, line.x1, line.y1)) {
                    return { lineIndex: i, endpoint: 'start', x: line.x1, y: line.y1 };
                }
                if (isNearPoint(x, y, line.x2, line.y2)) {
                    return { lineIndex: i, endpoint: 'end', x: line.x2, y: line.y2 };
                }
            }
            return null;
        }
        
        function findSymbolAtPosition(x, y) {
            for (let i = 0; i < symbols.length; i++) {
                const symbol = symbols[i];
                if (isNearPoint(x, y, symbol.x, symbol.y, 10)) {
                    return i;
                }
            }
            return null;
        }
        
        function drawSymbol(x, y, type, color, size, lineAngle = 0) {
            const radius = size * 2.5;
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            switch(type) {
                case 'dot':
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'arrow':
                    const arrowLength = 10 + size;
                    const arrowWidth = 6 + size;
                    const angle = lineAngle || 0;
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(
                        x - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle),
                        y - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle)
                    );
                    ctx.lineTo(
                        x - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle),
                        y - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle)
                    );
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'singleLine':
                    const perpAngle = lineAngle + Math.PI / 2;
                    const lineLen = radius * 1.5;
                    
                    ctx.beginPath();
                    ctx.moveTo(
                        x - lineLen * Math.cos(perpAngle),
                        y - lineLen * Math.sin(perpAngle)
                    );
                    ctx.lineTo(
                        x + lineLen * Math.cos(perpAngle),
                        y + lineLen * Math.sin(perpAngle)
                    );
                    ctx.stroke();
                    break;
                    
                case 'doubleLine':
                    const perpAngle2 = lineAngle + Math.PI / 2;
                    const lineLen2 = radius * 1.5;
                    const spacing = size * 2;
                    
                    // First line
                    ctx.beginPath();
                    ctx.moveTo(
                        x - lineLen2 * Math.cos(perpAngle2) - spacing * Math.cos(lineAngle),
                        y - lineLen2 * Math.sin(perpAngle2) - spacing * Math.sin(lineAngle)
                    );
                    ctx.lineTo(
                        x + lineLen2 * Math.cos(perpAngle2) - spacing * Math.cos(lineAngle),
                        y + lineLen2 * Math.sin(perpAngle2) - spacing * Math.sin(lineAngle)
                    );
                    ctx.stroke();
                    
                    // Second line
                    ctx.beginPath();
                    ctx.moveTo(
                        x - lineLen2 * Math.cos(perpAngle2) + spacing * Math.cos(lineAngle),
                        y - lineLen2 * Math.sin(perpAngle2) + spacing * Math.sin(lineAngle)
                    );
                    ctx.lineTo(
                        x + lineLen2 * Math.cos(perpAngle2) + spacing * Math.cos(lineAngle),
                        y + lineLen2 * Math.sin(perpAngle2) + spacing * Math.sin(lineAngle)
                    );
                    ctx.stroke();
                    break;
            }
        }
        
        function redrawCanvas() {
            drawGrid();
            
            // Draw all lines
            lines.forEach((line, index) => {
                ctx.strokeStyle = line.color;
                ctx.lineWidth = line.width;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(line.x1, line.y1);
                ctx.lineTo(line.x2, line.y2);
                ctx.stroke();
                
                // Draw arrow if endpoint is at bottom edge
                if (line.y2 === canvas.height) {
                    drawArrowhead(line.x1, line.y1, line.x2, line.y2, line.color, line.width);
                }
            });
            
            // Draw all symbols
            symbols.forEach((symbol) => {
                drawSymbol(symbol.x, symbol.y, symbol.type, symbol.color, symbol.size, symbol.lineAngle);
            });
            
            // Draw hover dots for line endpoints
            if (hoveredEndpoint && !draggingEndpoint && currentTool === 'adjust') {
                const line = lines[hoveredEndpoint.lineIndex];
                const x = hoveredEndpoint.endpoint === 'start' ? line.x1 : line.x2;
                const y = hoveredEndpoint.endpoint === 'start' ? line.y1 : line.y2;
                
                ctx.fillStyle = '#2196F3';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw hover indicator for symbols
            if (hoveredSymbol !== null && !draggingSymbol && currentTool === 'adjust') {
                const symbol = symbols[hoveredSymbol];
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(symbol.x, symbol.y, symbol.size * 2.5 + 3, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Draw helper line
            if (showHelperLine && mouseX >= 0) {
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(mouseX, 0);
                ctx.lineTo(mouseX, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        function drawArrowhead(x1, y1, x2, y2, color, width) {
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const arrowLength = 10 + width;
            const arrowWidth = 6 + width;
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(
                x2 - arrowLength * Math.cos(angle) - arrowWidth * Math.sin(angle),
                y2 - arrowLength * Math.sin(angle) + arrowWidth * Math.cos(angle)
            );
            ctx.lineTo(
                x2 - arrowLength * Math.cos(angle) + arrowWidth * Math.sin(angle),
                y2 - arrowLength * Math.sin(angle) - arrowWidth * Math.cos(angle)
            );
            ctx.closePath();
            ctx.fill();
        }
        
        function drawECG() {
    if (!currentLead || !ecgData) return;

    const leadData = ecgData[currentLead];
    if (!leadData) return;

    const padding = 10;
    const drawWidth = canvas.width - padding * 2;
    const drawHeight = ecgHeight - 40;
    const yOffset = 30;

    // Find min and max for scaling
    const min = Math.min(...leadData);
    const max = Math.max(...leadData);
    const range = max - min;
    if (range === 0) return;

    // Scaling for X coordinates
    const scaleX = drawWidth / leadData.length;

    // Pick a "ventricle line" — baseline at bottom of ECG plot
    const ventricleLineY = yOffset + drawHeight;

    // ---- QRS DETECTION ----
    const qrsRegions = detectQRS(leadData, 0.7, 8);

    // ---- DRAW ECG ----
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    ctx.beginPath();

    leadData.forEach((value, index) => {
        const x = padding + index * scaleX;
        const y = yOffset + drawHeight - ((value - min) / range) * drawHeight;
        if (index === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // ---- DRAW QRS MARKERS ----
    drawQRSMarkers(ctx, qrsRegions, ventricleLineY, padding, scaleX);
}
function detectQRS(signal, thresholdSlope = 0.5, minWidth = 10) {
    const derivative = [];
    for (let i = 1; i < signal.length; i++) {
        derivative.push(Math.abs(signal[i] - signal[i - 1]));
    }

    const qrsRegions = [];
    let inQRS = false;
    let start = 0;

    for (let i = 0; i < derivative.length; i++) {
        if (derivative[i] > thresholdSlope && !inQRS) {
            inQRS = true;
            start = i;
        } else if (derivative[i] <= thresholdSlope && inQRS) {
            inQRS = false;
            if (i - start >= minWidth) qrsRegions.push({ start, end: i });
        }
    }
    return qrsRegions;
}

function drawQRSMarkers(ctx, qrsRegions, ventricleLineY, padding, scaleX) {
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 1;

    qrsRegions.forEach(region => {
        const xStart = padding + region.start * scaleX;
        const xEnd = padding + region.end * scaleX;

        // Start line
        ctx.beginPath();
        ctx.moveTo(xStart, ventricleLineY);
        ctx.lineTo(xStart, ctx.canvas.height);
        ctx.stroke();

        // End line
        ctx.beginPath();
        ctx.moveTo(xEnd, ventricleLineY);
        ctx.lineTo(xEnd, ctx.canvas.height);
        ctx.stroke();
    });
}
        
        function parseECGXML(xmlText) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
            
            const parsedData = {};
            const leads = [];
            
            // Try RestECG format (RhythmLead elements)
            const rhythmLeads = xmlDoc.getElementsByTagName('RhythmLead');
            
            if (rhythmLeads.length > 0) {
                for (let i = 0; i < rhythmLeads.length; i++) {
                    const lead = rhythmLeads[i];
                    const leadIdElement = lead.getElementsByTagName('LeadId')[0];
                    const samplesElement = lead.getElementsByTagName('Samples')[0];
                    
                    if (leadIdElement && samplesElement) {
                        const leadName = leadIdElement.textContent.trim();
                        const base64Data = samplesElement.textContent.trim();
                        
                        try {
                            const binaryString = atob(base64Data);
                            const bytes = new Uint8Array(binaryString.length);
                            for (let j = 0; j < binaryString.length; j++) {
                                bytes[j] = binaryString.charCodeAt(j);
                            }
                            
                            // Parse 16-bit signed integers (little-endian)
                            const samples = [];
                            for (let j = 0; j < bytes.length - 1; j += 2) {
                                const value = bytes[j] | (bytes[j + 1] << 8);
                                samples.push(value > 32767 ? value - 65536 : value);
                            }
                            
                            if (samples.length > 0) {
                                parsedData[leadName] = samples;
                                leads.push(leadName);
                            }
                        } catch (e) {
                            console.error('Error parsing lead', leadName, e);
                        }
                    }
                }
            } else {
                // Try generic Waveform format
                const waveforms = xmlDoc.getElementsByTagName('Waveform');
                
                for (let i = 0; i < waveforms.length; i++) {
                    const waveform = waveforms[i];
                    const leadElement = waveform.getElementsByTagName('LeadID')[0] || 
                                       waveform.getElementsByTagName('lead')[0];
                    
                    if (!leadElement) continue;
                    
                    const leadName = leadElement.textContent.trim();
                    const waveformData = waveform.getElementsByTagName('WaveformData')[0] || 
                                        waveform.getElementsByTagName('data')[0];
                    
                    if (waveformData) {
                        const base64Data = waveformData.textContent.trim();
                        try {
                            const binaryString = atob(base64Data);
                            const bytes = new Uint8Array(binaryString.length);
                            for (let j = 0; j < binaryString.length; j++) {
                                bytes[j] = binaryString.charCodeAt(j);
                            }
                            
                            const samples = [];
                            for (let j = 0; j < bytes.length - 1; j += 2) {
                                const value = bytes[j] | (bytes[j + 1] << 8);
                                samples.push(value > 32767 ? value - 65536 : value);
                            }
                            
                            if (samples.length > 0) {
                                parsedData[leadName] = samples;
                                leads.push(leadName);
                            }
                        } catch (e) {
                            console.error('Error parsing lead', leadName, e);
                        }
                    }
                }
            }
            
            return { data: parsedData, leads: leads };
        }
        
        // Draw the ladder diagram grid
        function drawGrid() {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ECG area
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, ecgHeight);
            
            // ECG label
            ctx.fillStyle = '#333333';
            ctx.font = 'bold 16px Arial';
            ctx.textBaseline = 'top';
            ctx.fillText('ECG', 10, 10);
            
            // Draw ECG if available
            if (currentLead && ecgData) {
                drawECG();
            }
            
            // ECG bottom border (thicker)
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, ecgHeight);
            ctx.lineTo(canvas.width, ecgHeight);
            ctx.stroke();
            
            // Horizontal dividing lines (black and thicker)
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, atriaStart + atriaHeight);
            ctx.lineTo(canvas.width, atriaStart + atriaHeight);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, ventricleLine);
            ctx.lineTo(canvas.width, ventricleLine);
            ctx.stroke();
            
            // Vertical grid lines (every 40px, but not at edges)
            ctx.strokeStyle = '#eeeeee';
            ctx.lineWidth = 1;
            for (let x = 40; x < canvas.width; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, ecgHeight);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Labels - vertically centered in each chamber
            ctx.fillStyle = '#333333';
            ctx.font = 'bold 20px Arial';
            ctx.textBaseline = 'middle';
            ctx.fillText('A (Atria)', 10, atriaStart + atriaHeight / 2);
            ctx.fillText('AV (AV Node)', 10, atriaStart + atriaHeight + avHeight / 2);
            ctx.fillText('V (Ventricles)', 10, ventricleLine + ventricleHeight / 2);
        }
        
        function saveState() {
            history.push({
                lines: JSON.parse(JSON.stringify(lines)),
                symbols: JSON.parse(JSON.stringify(symbols)),
                dataUrl: canvas.toDataURL()
            });
            if (history.length > 20) {
                history.shift();
            }
        }
        
        function restoreState(state) {
            lines = JSON.parse(JSON.stringify(state.lines));
            symbols = JSON.parse(JSON.stringify(state.symbols));
            const img = new Image();
            img.onload = function() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
            };
            img.src = state.dataUrl;
        }
        
        // Initialize
        drawGrid();
        saveState();
        
        // Event listeners for tools
        document.getElementById('drawLine').addEventListener('click', function() {
            currentTool = 'line';
            document.querySelectorAll('.toolbar button').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            canvas.style.cursor = 'crosshair';
            hoveredEndpoint = null;
            redrawCanvas();
        });
        
        document.getElementById('adjust').addEventListener('click', function() {
            currentTool = 'adjust';
            document.querySelectorAll('.toolbar button').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            canvas.style.cursor = 'default';
        });
        
        document.getElementById('drawDot').addEventListener('click', function() {
            currentTool = 'dot';
            document.querySelectorAll('.toolbar button').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            canvas.style.cursor = 'crosshair';
            hoveredEndpoint = null;
            hoveredSymbol = null;
            redrawCanvas();
        });
        
        document.getElementById('symbolType').addEventListener('change', function(e) {
            currentSymbol = e.target.value;
        });
        
        // ECG file loading
        document.getElementById('ecgFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(event) {
                const xmlText = event.target.result;
                const result = parseECGXML(xmlText);
                
                if (result.leads.length > 0) {
                    ecgData = result.data;
                    ecgLeads = result.leads;
                    
                    // Populate dropdown
                    const dropdown = document.getElementById('leadDropdown');
                    dropdown.innerHTML = '';
                    ecgLeads.forEach(lead => {
                        const option = document.createElement('option');
                        option.value = lead;
                        option.textContent = lead;
                        dropdown.appendChild(option);
                    });
                    
                    currentLead = ecgLeads[0];
                    document.getElementById('leadSelector').style.display = 'flex';
                    redrawCanvas();
                } else {
                    alert('No valid ECG leads found in the XML file.');
                }
            };
            reader.readAsText(file);
        });
        
        document.getElementById('leadDropdown').addEventListener('change', function(e) {
            currentLead = e.target.value;
            redrawCanvas();
        });
        
        document.getElementById('eraser').addEventListener('click', function() {
            currentTool = 'eraser';
            document.querySelectorAll('.toolbar button').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            canvas.style.cursor = 'crosshair';
            hoveredEndpoint = null;
            redrawCanvas();
        });
        
        document.getElementById('colorPicker').addEventListener('change', function(e) {
            currentColor = e.target.value;
        });
        
        document.getElementById('lineWidth').addEventListener('change', function(e) {
            currentLineWidth = parseInt(e.target.value);
        });
        
        document.getElementById('undo').addEventListener('click', function() {
            if (history.length > 1) {
                history.pop();
                restoreState(history[history.length - 1]);
            } else if (history.length === 1) {
                lines = [];
                drawGrid();
            }
        });
        
        document.getElementById('clear').addEventListener('click', function() {
            lines = [];
            symbols = [];
            drawGrid();
            history = [];
            saveState();
        });
        
        // Drawing functions
        canvas.addEventListener('mousedown', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicking on an endpoint or symbol (only in adjust mode)
            if (currentTool === 'adjust') {
                const endpoint = findEndpointAtPosition(x, y);
                if (endpoint) {
                    draggingEndpoint = endpoint;
                    return;
                }
                
                const symbolIndex = findSymbolAtPosition(x, y);
                if (symbolIndex !== null) {
                    draggingSymbol = symbolIndex;
                    return;
                }
                return;
            }
            
            if (currentTool === 'line') {
                isDrawing = true;
                startX = x;
                startY = snapToLine(y);
                tempStartX = startX;
                tempStartY = startY;
                
                // Save current canvas state to temp canvas
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.drawImage(canvas, 0, 0);
            } else if (currentTool === 'dot') {
                // Find nearest endpoint to snap to
                const endpoint = findEndpointAtPosition(x, y);
                if (endpoint) {
                    // Find the line to calculate angle
                    const line = lines[endpoint.lineIndex];
                    const lineAngle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
                    
                    symbols.push({
                        x: endpoint.x,
                        y: endpoint.y,
                        type: currentSymbol,
                        color: currentColor,
                        size: currentLineWidth,
                        lineAngle: lineAngle,
                        lineIndex: endpoint.lineIndex,
                        endpoint: endpoint.endpoint
                    });
                    redrawCanvas();
                    saveState();
                }
            } else if (currentTool === 'eraser') {
                isDrawing = true;
                startX = x;
                startY = y;
            }
        });
        
        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Update helper line position
            mouseX = x;
            
            // Handle endpoint dragging
            if (draggingEndpoint) {
                const line = lines[draggingEndpoint.lineIndex];
                const snappedY = snapToLine(y);
                
                if (draggingEndpoint.endpoint === 'start') {
                    line.x1 = x;
                    line.y1 = snappedY;
                } else {
                    line.x2 = x;
                    line.y2 = snappedY;
                }
                
                redrawCanvas();
                return;
            }
            
            // Handle symbol dragging
            if (draggingSymbol !== null) {
                const endpoint = findEndpointAtPosition(x, y);
                if (endpoint) {
                    const line = lines[endpoint.lineIndex];
                    const lineAngle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
                    
                    symbols[draggingSymbol].x = endpoint.x;
                    symbols[draggingSymbol].y = endpoint.y;
                    symbols[draggingSymbol].lineAngle = lineAngle;
                    symbols[draggingSymbol].lineIndex = endpoint.lineIndex;
                    symbols[draggingSymbol].endpoint = endpoint.endpoint;
                    redrawCanvas();
                }
                return;
            }
            
            // Handle hover detection when in adjust mode
            if (currentTool === 'adjust') {
                const endpoint = findEndpointAtPosition(x, y);
                const symbolIndex = findSymbolAtPosition(x, y);
                
                if (endpoint || symbolIndex !== null) {
                    hoveredEndpoint = endpoint;
                    hoveredSymbol = symbolIndex;
                    canvas.style.cursor = 'pointer';
                    showHelperLine = false;
                    redrawCanvas();
                } else if (hoveredEndpoint || hoveredSymbol !== null) {
                    hoveredEndpoint = null;
                    hoveredSymbol = null;
                    canvas.style.cursor = 'default';
                    showHelperLine = true;
                    redrawCanvas();
                } else {
                    showHelperLine = true;
                    redrawCanvas();
                }
                return;
            }
            
            // Handle hover in dot mode
            if (currentTool === 'dot') {
                const endpoint = findEndpointAtPosition(x, y);
                if (endpoint) {
                    canvas.style.cursor = 'pointer';
                    showHelperLine = false;
                } else {
                    canvas.style.cursor = 'crosshair';
                    showHelperLine = true;
                }
                redrawCanvas();
                return;
            }
            
            // Show helper line for other tools
            if (currentTool === 'line' || currentTool === 'eraser') {
                showHelperLine = true;
            }
            
            if (!isDrawing) {
                redrawCanvas();
                return;
            }
            
            if (currentTool === 'line') {
                const snappedY = snapToLine(y);
                
                // Restore canvas from temp
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(tempCanvas, 0, 0);
                
                // Draw preview line
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentLineWidth;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(tempStartX, tempStartY);
                ctx.lineTo(x, snappedY);
                ctx.stroke();
                
                // Draw arrow if endpoint is at bottom edge
                if (snappedY === canvas.height) {
                    drawArrowhead(tempStartX, tempStartY, x, snappedY, currentColor, currentLineWidth);
                }
                
                // Draw helper line
                if (showHelperLine) {
                    ctx.strokeStyle = '#2196F3';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(mouseX, 0);
                    ctx.lineTo(mouseX, canvas.height);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            } else if (currentTool === 'eraser') {
                ctx.clearRect(x - 10, y - 10, 20, 20);
                // Redraw grid lines in erased area
                if (Math.abs(y - (atriaStart + atriaHeight)) < 10 || Math.abs(y - ventricleLine) < 10) {
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const lineY = Math.abs(y - (atriaStart + atriaHeight)) < 10 ? (atriaStart + atriaHeight) : ventricleLine;
                    ctx.moveTo(x - 10, lineY);
                    ctx.lineTo(x + 10, lineY);
                    ctx.stroke();
                }
                startX = x;
                startY = y;
            }
        });
        
        canvas.addEventListener('mouseup', function(e) {
            if (draggingEndpoint) {
                draggingEndpoint = null;
                saveState();
                return;
            }
            
            if (draggingSymbol !== null) {
                draggingSymbol = null;
                saveState();
                return;
            }
            
            if (isDrawing && currentTool === 'line') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const snappedY = snapToLine(y);
                
                // Add line to array
                lines.push({
                    x1: tempStartX,
                    y1: tempStartY,
                    x2: x,
                    y2: snappedY,
                    color: currentColor,
                    width: currentLineWidth
                });
                
                redrawCanvas();
                saveState();
            }
            
            if (isDrawing) {
                isDrawing = false;
                if (currentTool === 'eraser') {
                    saveState();
                }
            }
        });
        
        canvas.addEventListener('mouseenter', function() {
            showHelperLine = true;
        });
        
        canvas.addEventListener('mouseleave', function() {
            isDrawing = false;
            showHelperLine = false;
            redrawCanvas();
        });
    </script>
</body>
</html>
